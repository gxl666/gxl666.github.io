<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>User guide for 4.x | Javaer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="User guide for 4.x">
<meta property="og:type" content="article">
<meta property="og:title" content="User guide for 4.x">
<meta property="og:url" content="http://gxl666.github.io/2016/11/07/User-guide-for-4-x/index.html">
<meta property="og:site_name" content="Javaer">
<meta property="og:description" content="User guide for 4.x">
<meta property="og:image" content="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262">
<meta property="og:image" content="https://camo.githubusercontent.com/5b595baf5071bf669f81d08b7554064f4142cc69/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f6233316330626437626266633639666438326436">
<meta property="og:image" content="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262">
<meta property="og:updated_time" content="2016-11-08T14:14:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="User guide for 4.x">
<meta name="twitter:description" content="User guide for 4.x">
<meta name="twitter:image" content="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262">
  
    <link rel="alternate" href="/atom.xml" title="Javaer" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Javaer</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Just for fun</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://gxl666.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-User-guide-for-4-x" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/07/User-guide-for-4-x/" class="article-date">
  <time datetime="2016-11-07T09:13:53.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      User guide for 4.x
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>User guide for 4.x<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="令人头疼的问题"><a href="#令人头疼的问题" class="headerlink" title="令人头疼的问题"></a>令人头疼的问题</h3><p>现在我们一般使用通用应用程序或者类库互相通信。例如，我们经常使用一个 HTTP 客户端类库从 WEB 服务器上获取信息，或者通过 Web 服务来实现远程方法调用。然而，一个通用的协议或者其实现有时候并没有良好的伸缩性。这就像是我们不会使用一个通用的 HTTP 服务器来传输大文件，e-mail 信息，或者金融信息和多玩家游戏数据那样的实时性要求很高的信息。一个通用型的最优化的协议实现要求什么呢？例如，你可能想实现一个 HTTP 服务器，需要同时用于基于 AJAX的 聊天应用，提供流媒体服务或者大文件传输功能。你也许会想针对自己的需求设计并实一整套新的协议。另外有一种不可避免的情况就是，为了与一个旧系统进行通信，你必须得处理一个旧系统专属的协议。在这种情况下，我们怎么在不牺牲稳定性和性能的前提下快速实现我们的协议？</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>对于快速开发可维护、高性能并且伸缩性良好的协议服务器和客户端，Netty 提供了一种异步事件驱动网络应用框架。<br>换句话说，Netty 是一个 NIO 客户端服务器框架，它让我们开发像协议服务器或客户端等这些网络应用变得快速而简单。它极大的简化了像 TCP 和 UDP 套接字等网络编程。<br>“快速且容易”并不意味着会导致维护或性能问题。Netty 是在充分考虑了大量的网络协议如 FTP,SMTP,HTTP 和 大量的历史遗留的基于二进制和基于文本的协议之后被设计出来的。因此，Netty 成功地实现了易开发、高性能、高稳定性、强可伸缩性这些优点。<br>一些用户可能也发现了其他的声称有和 Netty 相同优势的网络应用框架，所以你会问 Netty 与那些框架有什么不同呢。答案就是 Netty 依据的哲学。在 API 和具体实现上，Netty 是在充分考虑了用户使用体验后设计出来的。虽然有时候并不现实，但在阅读了指南和 API 后，你将会意识到 Netty 让你的生活变得简单的哲学。</p>
<h2 id="开始跑两步"><a href="#开始跑两步" class="headerlink" title="开始跑两步"></a>开始跑两步</h2><p>这章主要围绕 Netty 核心构造的讲解，并辅以可以让你快速上手的简单示例。当你阅读到本章末尾时，你就可以写一个基于 Netty 的客户端和服务器。<br>如果你更喜欢自顶向下的学习方式，你也可以从第二章-架构概览看起，看完第二章后再回到这里。</p>
<h3 id="前景提示"><a href="#前景提示" class="headerlink" title="前景提示"></a>前景提示</h3><p>运行本章介绍的实例有两个前提——最新版本的 Netty 和 1.6以上的 JDK 版本。最新的 Netty 版本可以在<a href="http://netty.io/downloads.html" target="_blank" rel="external">下载</a>页面找到。为了可以下载到正确的 JDK 版本，请参考你喜欢的 JDK 供应商的网站。<br>在你阅读学习本章的过程中，对于本章提到的类你可能有很多疑问。当你想知道这些类的详细信息时，可以去查阅 API 文档。为了方便学习者，本文中所有的类都链接到了在线的 API 文档。当然，如果你发现了任何异常、错误的语法以及排版错误，或者你有更好地改进该文档的想法请毫不犹豫的联系<a href="http://netty.io/community.html" target="_blank" rel="external">Netty 社区</a>来告知我们。</p>
<h3 id="写一个拒绝一切的服务器"><a href="#写一个拒绝一切的服务器" class="headerlink" title="写一个拒绝一切的服务器"></a>写一个拒绝一切的服务器</h3><p>最简单的协议服务器并不是“Hello，World！”而是<a href="https://tools.ietf.org/html/rfc863" target="_blank" rel="external">DISCARD</a>。<br>为了实现 DISCARD 协议，我们需要做的仅仅是忽略所有接收到的数据。让我们直接从处理器实现开始，它是 Netty 生成的，用来处理 I/O 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.discard;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Handles a server-side channel.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123; <span class="comment">// (1)</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123; <span class="comment">// (2)</span></div><div class="line">        <span class="comment">// Discard the received data silently.</span></div><div class="line">        ((ByteBuf) msg).release(); <span class="comment">// (3)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123; <span class="comment">// (4)</span></div><div class="line">        <span class="comment">// Close the connection when an exception is raised.</span></div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>DiscardServerHandler</code> 继承了 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html" target="_blank" rel="external">ChannelInboundHandlerAdapter</a>，而 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html" target="_blank" rel="external">ChannelInboundHandlerAdapter</a> 实现了 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html" target="_blank" rel="external">ChannelInboundHandler</a>。<a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html" target="_blank" rel="external">ChannelInboundHandler</a> 提供了大量的我们可以重写的事件处理方法。就目前的问题，我们只需要继承 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html" target="_blank" rel="external">ChannelInboundHandlerAdapter</a> 就够了，而不需要自己实现接口 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html" target="_blank" rel="external">ChannelInboundHandler</a>。</li>
<li>本例中，我们重写了 <code>channelRead()</code> 事件处理方法。当接收到来自客户端的新的数据后，这个方法就会被调用。在这个例子中，接收到的信息的类型是 <a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。</li>
<li><p>为了实现 DISCARD 协议服务器，处理器必须忽略接收到的信息。<a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a> 是一个不得不通过 <code>release()</code> 方法释放的引用计数对象。请记住：必须在处理器中释放掉任何传入处理器的引用记数对象。一般地，<code>channelRead()</code> 处理方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Do something with msg</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ReferenceCountUtil.release(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>exceptionCaught()</code> 事件处理方法会在 Netty 产生了 I/O 错误或者处理器的实现方法中产生了异常时被调用。大多数情况下，应该以日志记录捕获的异常，并将其相关的通信通道关闭掉，但实际的实现依赖于用户自己处理异常的情景。例如，也许你想要在关闭通信连接之前发送一个附带错误码的错误信息响应。</p>
</li>
</ol>
<p>到目前为止，我们已经实现了 DISCARD 服务器的第一部分。现在剩下的是在 <code>main()</code> 方法中使用 DiscardServerHandler 启动服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.discard;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</div><div class="line"></div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</div><div class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</div><div class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</div><div class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</div><div class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</div><div class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Discards any incoming data.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span></div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></div><div class="line">            b.group(bossGroup, workerGroup)</div><div class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span></div><div class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></div><div class="line">                 <span class="meta">@Override</span></div><div class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</div><div class="line">                 &#125;</div><div class="line">             &#125;)</div><div class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></div><div class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></div><div class="line"></div><div class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></div><div class="line">            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></div><div class="line"></div><div class="line">            <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></div><div class="line">            <span class="comment">// shut down your server.</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">            bossGroup.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> port;</div><div class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            port = <span class="number">8080</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">new</span> DiscardServer(port).run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><a href="http://netty.io/4.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a> 是一个处理 I/O 操作的多线程循环事件处理器。为了应对不同的传输类型，Netty 提供了大量的 <a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a> 的实现。本例中，我们正在实现一个服务端应用，因此两个 <a href="http://netty.io/4.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a> 将被用到。第一个，通常被称为 ‘boss’，接收一个即将到来的连接。第二个，通常被称为 ‘worker’，当 ‘boss’ 接受了连接并向 ‘worker’ 注册了这个连接，’worker’ 就会处理连接上的流量。使用多少个线程以及这些线程怎么被映射到 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>s 取决于 <a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a> 的实现，甚至也可以通过构造方法来配置。</li>
<li><a href="http://netty.io/4.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a> 是一个可以帮我们建立一个服务器的工具类。你可以通过直接使用 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a> 来建立服务器。然而，那个过程是极其繁杂无聊的，并且大多数情况下我们都不必这么做。</li>
<li>这里，我们使用了 <a href="http://netty.io/4.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a> 类来初始化一个可以接收连接的 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。</li>
<li>处理器每次都将使用一个新的 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。<a href="http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a> 是个特殊的处理器，旨在帮一个用户配置一个新的 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。对于一个新的 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>，大多数时候我们更想通过配置其 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a> 来添加像 <code>DiscardServerHandler</code> 这样的处理器来实现网络应用。随着网络应用程序变得逐渐复杂，我们更可能是添加更多的处理器到 ‘pipeline’ 上和一些匿名类到顶级类上。</li>
<li>你也可以添加一下参数到 <code>Channel</code> 的实现上。这里我们正在写一个 TCP/IP 服务器，因此我们可以设置像 <code>tcpNodelay</code> 和 <code>keepAlive</code> 等套接字选项。可以去查阅 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="external">ChannelOption</a> 和 <a href="http://netty.io/4.0/api/io/netty/channel/ChannelConfig.html" target="_blank" rel="external">ChannelConfig</a> 实现的 API 文档去学习如何配置 <code>ChannelOption</code>S。</li>
<li>不知道你是否已经注意到 <code>option()</code> 和 <code>childOption()</code> 了？<code>option()</code> 是为了设置接收即将到来的连接的 <a href="http://netty.io/4.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a> 。<code>childOption()</code> 是为了设置从父 <a href="http://netty.io/4.0/api/io/netty/channel/ServerChannel.html" target="_blank" rel="external">ServerChannel</a> 那里接受的 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>S，在这里是 <a href="http://netty.io/4.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>。</li>
<li>现在我们准备去跑一下这个程序。剩下的就是绑定端口号并启动这个服务器。在这里，我们绑定了端口号 8080。你现在可以随意调用 <code>bind()</code> 方法多次去绑定不同的地址。</li>
</ol>
<p>恭喜！你已经编码完成了你的第一个基于 Netty 的服务器（Ps：这个例子并不好玩！）。</p>
<h3 id="查看接收到的数据"><a href="#查看接收到的数据" class="headerlink" title="查看接收到的数据"></a>查看接收到的数据</h3><p>现在我们已经写好了我们第一个服务器，我们需要测试下它是否可以正常工作。最简单的测试方法是使用 <code>telnet</code> 命令。例如，你可以在命令行中输入 <code>telnet localhost 8080</code> 并输入一些内容。<br>然而，我们可以认为服务器已经可以正常工作了吗？因为它是一个拒绝一切的服务器，所以我们并不能就这么理所当让的认为它是正常工作的。我们不会从服务器得到任何响应信息。因此，为了证明服务器是正常工作的，我们要去修改代码——将收到的信息打印出来。<br>我们已经知道：在接收到数据时，<code>channelRead()</code> 方法将被调用。让我们再往 <code>channelRead()</code> 方法中添加些代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">    ByteBuf in = (ByteBuf) msg;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (in.isReadable()) &#123; <span class="comment">// (1)</span></div><div class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</div><div class="line">            System.out.flush();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ReferenceCountUtil.release(msg); <span class="comment">// (2)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>这里的无限循环实际上是相当简单的：<code>System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</code></li>
<li>在这里是否要调用 <code>in.release()</code> 是可选的</li>
</ol>
<p>完整的代码在 Netty 发行版的<a href="http://netty.io/4.0/xref/io/netty/example/discard/package-summary.html" target="_blank" rel="external">io.netty.example.discard</a>中。</p>
<h3 id="写一个回显服务器"><a href="#写一个回显服务器" class="headerlink" title="写一个回显服务器"></a>写一个回显服务器</h3><p>到目前为止，我们已经丢掉了接收到的数据，并没有任何响应。然而，一个服务器通常要对请求做出一些响应的。接下来通过实现一个<a href="http://tools.ietf.org/html/rfc862" target="_blank" rel="external">ECHO</a>让我们学习怎么向客户端返回响应信息——即将客户端发来的数据原封不动的返回回去。<br>回显服务器与拒绝一切的服务器唯一的不同在于它将接收到的数据返回而不是将其打印在控制台。因此，我们仅仅需要修改下 <code>channelRead()</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">    ctx.write(msg); <span class="comment">// (1)</span></div><div class="line">    ctx.flush(); <span class="comment">// (2)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><code>ChannelHandlerContext</code> 对象提供很多操作方法可以让用户触发各种各样的 I/O 事件。这里，我们调用了 <code>write(Object)</code> 方法来一字不差的输出接收到的信息。请注意：这里我们并没有像 DISCARD 那样手动释放接收到的信息。因为当信息全部写完到连线信道后 Netty 会自动帮我们释放它。</li>
<li><code>ctx.write(Object)</code> 并没有将信息全部写到连线信道。它仅是内部缓存了而已，下面的 <code>ctx.flush()</code> 才是将信息全部写入到连线信道。当然了，你也可以直接使用 <code>ctx.writeAndFlush(msg)</code>。</li>
</ol>
<p>如果你再次运行 telnet 命令测试的话，你就会发现无论你发送了什么就能接收到什么。<br>完整的代码在 Netty 发行版的<a href="http://netty.io/4.0/xref/io/netty/example/echo/package-summary.html" target="_blank" rel="external">io.netty.example.echo</a>中。</p>
<h3 id="写一个时间服务器"><a href="#写一个时间服务器" class="headerlink" title="写一个时间服务器"></a>写一个时间服务器</h3><p>这个小节中我们将会实现基于一个<a href="http://tools.ietf.org/html/rfc868" target="_blank" rel="external">TIME</a>协议的服务器。它与之前的例子是不同的，无论服务器端接收到什么请求，它都将返回一个包含着 32 个比特位的整型消息，并且一旦响应发送出去就关闭连接。通过本例，你将会学习到怎么构造并发送一个消息，发送完成之后关闭连接。<br>因为我们要实现的是忽略所有接收到的信息并返回一个信息，所以我们这里不能再使用 <code>channelRead()</code> 方法了。相应地，我们应该重写 <code>channelActive()</code> 方法。下面是该方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx)</span> </span>&#123; <span class="comment">// (1)</span></div><div class="line">        <span class="keyword">final</span> ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (2)</span></div><div class="line">        time.writeInt((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(time); <span class="comment">// (3)</span></div><div class="line">        f.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</div><div class="line">                <span class="keyword">assert</span> f == future;</div><div class="line">                ctx.close();</div><div class="line">            &#125;</div><div class="line">        &#125;); <span class="comment">// (4)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>正如上文的解释，当一个连接建立后并可以进行传输流量时，<code>channelActive()</code>  将会被调用。接下来我们向通信连线上写入了代表着当前时间的 32 个比特位的整型数字。</li>
<li>为了写入一个新的消息，我们需要分配一个新的 buffer ，用来存储新消息。因为我们需要写入一个 32 比特位的整数，所以我们需要新建一个至少包含 4 个字节的<a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>类型。通过 <code>ChannelHandlerContext.alloc()</code> 我们获取到当前的<a href="http://netty.io/4.0/api/io/netty/buffer/ByteBufAllocator.html" target="_blank" rel="external">ByteBufAllocator</a>并分配一个新的 buffer。</li>
<li>通常，我们是写入一个构造好的信息。<br>但是等等，<code>flip</code> 在哪呢？过去我们使用 NIO 发送一个消息之前，是不是会经常调用 <code>java.nio.ByteBuffer.flip()</code> 呢？ 因为其实索引点和结束索引点，所以<code>ByteBuf</code> 并没有这样的方法；一个用来读操作，另一个用来写操作。当你向 <code>ByteBuf</code> 写入一些内容，写索引值将会增加，而读索引值并没有变。读索引值和写索引值分别代表代表着信息起始索引值和结束索引值。<br>相比之下，NIO buffer 没有提供一个清空信息的方法来获取信息的起始索引值和结束索引值。如果你忘记调用 <code>flip</code> 方法就会很蛋疼，因为这样是没有任何数据被发送的。Netty 中就不会有这种问题，因为我们有起始索引值和结束索引值并且有不同的操作。你就会发现这使你的生活变得更容易——不必在时刻记着 <code>flip</code>。<br>其他需要注意的地方就是 <code>ChannelHandlerContext.write()</code> （和 <code>writeAndFlush()</code>）方法会返回一个<a href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>。<a href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a> 代表一个尚未发生的 I/O 操作。这也就意味着，任何请求操作可能都尚未发生，因为在 Netty 中任何操作都是异步的嘛。例如，下面的代码可能在消息被发送之前就关闭了连接：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Channel ch = ...;</div><div class="line">ch.writeAndFlush(message);</div><div class="line">ch.close();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>因为你需要在<a href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>完成之后调用 <code>close()</code> 方法，正如上面代码所示，我们在 <code>ChannelFuture</code> 中添加了监听器，并注册了其操作完成的监听方法。请注意，<code>close()</code> 方法也许不会立即关闭连接，并且它会返回一个<a href="http://netty.io/4.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>。</p>
<ol>
<li>我们怎么捕获到一个写入要求完成事件呢？这时我们只需要在 <code>Channel Future</code> 上添加一个监听器<a href="http://netty.io/4.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>。这里我们新建了一个匿名的<a href="http://netty.io/4.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>在操作完成之后关闭连接。</li>
<li>可选的，你可以用一个预定义的监听器来简化代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f.addListener(ChannelFutureListener.CLOSE);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了测试我们的时间服务器是否正常工作，我们使用 UNIX 下的 <code>rdate</code> 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rdate -o &lt;port&gt; -p &lt;host&gt;</div></pre></td></tr></table></figure></p>
<p><port> 就是我们在 <code>main()</code> 方法中指定的端口号，<host> 则一般是 localhost。</host></port></p>
<h3 id="写一个时间客户端"><a href="#写一个时间客户端" class="headerlink" title="写一个时间客户端"></a>写一个时间客户端</h3><p>不像 DISCARD 和 ECHO 服务器，我们需要一个客户端来将 32 个比特位的数据转换成一个人类可读的日期。这个小节里，我们将探讨如何确定时间服务器是正常工作的，并且学习使用 Netty 如何写一个时间客户端。<br>使用 Netty 写一个客户端和一个服务器有且仅有的不同就是用到的<a href="http://netty.io/4.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">Bootstrap</a>和<a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>的实现的不同。请看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String host = args[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></div><div class="line">            b.group(workerGroup); <span class="comment">// (2)</span></div><div class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></div><div class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></div><div class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="comment">// Start the client.</span></div><div class="line">            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span></div><div class="line"></div><div class="line">            <span class="comment">// Wait until the connection is closed.</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><a href="http://netty.io/4.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">Bootstrap</a> 和 <a href="http://netty.io/4.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a>是相似的，除了它是像客户端或无连接的非服务类型的通信信道。</li>
<li>如果你仅仅为<a href="http://netty.io/4.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">Bootstrap</a>设置了一个<a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>，那么这个<a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>将会充当 boss 和 worker 的角色。当然，boss worker 在客户端是没用的。</li>
<li>相应地，<a href="http://netty.io/4.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" target="_blank" rel="external">NioSocketChannel</a> 也替代了<a href="http://netty.io/4.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>被用来在客户端创建<a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。</li>
<li>请注意这里我们没有使用 <code>childOption()</code> 方法，因为客户端<a href="http://netty.io/4.0/api/io/netty/channel/socket/SocketChannel.html" target="_blank" rel="external">SocketChannel</a>没有一个父亲类。</li>
<li>在客户端，我们也应该使用 <code>connect()</code> 方法代替 <code>bind()</code> 方法。</li>
</ol>
<p>正如你看到的，客户端的代码和服务器端的确实有很多不同。那么<a href="http://netty.io/4.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>该怎么实现呢？它应该从服务器端接收一个 32 位的整数，并将其转换为人类可读的形式打印出来，最后关闭连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">        ByteBuf m = (ByteBuf) msg; <span class="comment">// (1)</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;</div><div class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</div><div class="line">            ctx.close();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            m.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>依照 TCP/IP 协议，Netty 将接收到的数据读入一个<a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。</li>
</ol>
<p>客户端代码看起来很简单并且和服务器端代码看起来没太多不同。然而，这个处理器有时会出现异常 <code>IndexOutOfBoundsException</code> 。我们将在下一小节中讨论这个问题。</p>
<h3 id="处理一个基于流传输的问题"><a href="#处理一个基于流传输的问题" class="headerlink" title="处理一个基于流传输的问题"></a>处理一个基于流传输的问题</h3><h4 id="套接字缓存的一个小告警"><a href="#套接字缓存的一个小告警" class="headerlink" title="套接字缓存的一个小告警"></a>套接字缓存的一个小告警</h4><p>在使用像 TCP/IP 等基于流的传输时，接收到的数据被存储在套接字缓存中。不幸的是，基于流的缓存保存的不是一个分包队列而是字节队列。这意味着，即使你使用两个相互独立的包发送了两个消息，操作系统也仅仅是将其作为一批字节对待而已，并未对这两个包做区分。因此，客户端读到的数据并不能保证就是服务器写入的信息。例如，假设操作系统的 TCP/IP 栈已经收到了三个包：<br><img src="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262" alt=""><br>因为是基于流的协议，所以我们的应用程序有很高的可能性像下面分成帧的形式读取它们：<br><img src="https://camo.githubusercontent.com/5b595baf5071bf669f81d08b7554064f4142cc69/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f6233316330626437626266633639666438326436" alt=""><br>因此，一个接收方，无论是服务器端还是客户端都应该整理接收到的数据，将其转换为有意义的并方便应用程序理解的帧格式。上例中，接收到的数据的整理后的帧格式就像下面这样：<br><img src="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262" alt=""></p>
<h4 id="第一个解决方法"><a href="#第一个解决方法" class="headerlink" title="第一个解决方法"></a>第一个解决方法</h4><p>现在再让我们看看 TIME 客户端的例子。这个例子中就有这个问题。一个 32 位的整数是量非常小的数据，并且通常情况下它是不会被分帧的。然而，问题是它有可能会被分帧，并且随着流量的增加分帧的可能性也随之增加。<br>最简单的解决方法是创建一个内部累加缓存，直到从内部缓存中得到 4 个字节的数字。修复了问题的 <code>TimeClientHandler</code> 的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ByteBuf buf;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">        buf = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (1)</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">        buf.release(); <span class="comment">// (1)</span></div><div class="line">        buf = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">        ByteBuf m = (ByteBuf) msg;</div><div class="line">        buf.writeBytes(m); <span class="comment">// (2)</span></div><div class="line">        m.release();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (buf.readableBytes() &gt;= <span class="number">4</span>) &#123; <span class="comment">// (3)</span></div><div class="line">            <span class="keyword">long</span> currentTimeMillis = (buf.readUnsignedInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;</div><div class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</div><div class="line">            ctx.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><a href="http://netty.io/4.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a> 有两个生命周期方法：<code>handlerAdded()</code> 和 <code>handlerRemoved()</code> 。你可以在这两个方法中进行一些不会阻塞太长时间的初始化工作或者收尾工作 。</li>
<li>首先，所有接收到的数据都应该累计缓存到 buf。</li>
<li>然后，处理器首先要检测 buf 是否有足够的数据（本例中即 4 个字节），然后再处理实际的业务逻辑。要不然，当接收到更多的数据时，Netty 将会再次调用 <code>ChannelRead()</code> 方法，最终所有的 4 字节都将会被缓存。</li>
</ol>
<h4 id="第二个解决方法"><a href="#第二个解决方法" class="headerlink" title="第二个解决方法"></a>第二个解决方法</h4><p>尽管第一个解决方法已经完美地解决了这个问题，但是修改后的处理器代码看起来并不是那么清晰。想象下如果一个更复杂的协议需要传输多个不同长度的字段。你的<a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html" target="_blank" rel="external">ChannelInboundHandler</a>实现很快就会变得不可维护。<br>正如你可以猜到的，你可以增加超过一个<a href="http://netty.io/4.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>到<a href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>，因此，你可以分离出一个<a href="http://netty.io/4.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>作为单独的模块来降低应用程序的复杂度。例如，你可以将 TimeClientHandler 分割成两个处理器：</p>
<ul>
<li>用来处理分帧问题的 TimeDecoder，和</li>
<li>刚开始的最简单的 TimeClientHandler 版本</li>
</ul>
<p>幸运的是，Netty 提供了一个扩展类来帮助你写第一个处理器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123; <span class="comment">// (1)</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123; <span class="comment">// (2)</span></div><div class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">// (3)</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        out.add(in.readBytes(<span class="number">4</span>)); <span class="comment">// (4)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><a href="http://netty.io/4.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>是<a href="http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html" target="_blank" rel="external">ChannelInboundHandler</a>的一个实现，使用<a href="http://netty.io/4.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>可以很容易的处理分帧问题。</li>
<li>无论何时接收到数据，<a href="http://netty.io/4.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>都会调用内部附带可维护的缓存的 <code>decode()</code> 方法。</li>
<li>在没有接收到足够的数据时，<code>decode()</code> 方法被设计成不会接收任何数据。并且，只要有接收到了更多的数据，<code>decode()</code> 方法会被再次调用。</li>
<li>如果 <code>decode()</code> 方法在 out 中添加了一个对象，则说明解析器已经成功解析了一个消息。<a href="http://netty.io/4.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>将会丢弃已读取的内部缓存数据。请牢记：你不需要自己解析多个消息。<a href="http://netty.io/4.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>会一直调用 <code>decode()</code> 方法，直到它不再向 out 中添加任何数据。</li>
</ol>
<p>现在我们有更多的处理器要插入到<a href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>，我们应该修改<a href="http://netty.io/4.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitizlizer</a>的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ch.pipeline().addLast(<span class="keyword">new</span> TimeDecoder(), <span class="keyword">new</span> TimeClientHandler());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果你对 Netty 足够了解，也许你想试试可以再次简化解析器的<a href="http://netty.io/4.0/api/io/netty/handler/codec/ReplayingDecoder.html" target="_blank" rel="external">ReplayingDecoder</a>。如果需要了解详情，你需要去查阅 API 文档。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(</span></span></div><div class="line">            ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) &#123;</div><div class="line">        out.add(in.readBytes(<span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，Netty 提供了 out-of-the-box 解析器，可以帮助你轻松地实现更多的协议，并让处理器的实现有更高的可维护性。欲知详情，请参考如下包中的例子：</p>
<ul>
<li>对应于二进制协议的<a href="http://netty.io/4.0/xref/io/netty/example/factorial/package-summary.html" target="_blank" rel="external">io.netty.example.factorial</a>和</li>
<li>对应于文本协议的<a href="http://netty.io/4.0/xref/io/netty/example/telnet/package-summary.html" target="_blank" rel="external">io.netty.example.telnet</a></li>
</ul>
<h3 id="使用-POJO-代替-ByteBuf"><a href="#使用-POJO-代替-ByteBuf" class="headerlink" title="使用 POJO 代替 ByteBuf"></a>使用 POJO 代替 ByteBuf</h3><p>到目前为止，我们学习到的所有例子都是使用 ByteBuf 作为协议消息的数据结构。这个小节中，我们将使用 POJO 来代替 ByteBuf 来改进 TIME 协议服务器和客户端。<br>在<a href="http://netty.io/4.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>S中使用 POJO 的效果是明显的；通过分离处理器中的ByteBuf，来提高处理器的可维护性和重用性。在 TIME 客户端和服务器的例子中，我们仅仅是读取一个 32 位的整数，所以直接使用 ByteBuf 并没有直接的问题。然而，当你实现一个真正的协议服务器时你将会发现从你的处理器中分离 ByteBuf 是非常必要的。<br>首先，让我们定义一个新的类型 UnixTime：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnixTime</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date((value() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>).toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们现在可以重构 TimeDecoder 产生一个 UnixTime 对象来替换 <a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    out.add(<span class="keyword">new</span> UnixTime(in.readUnsignedInt()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟随着解析器的更新，TimeClientHandler 也不再使用<a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</div><div class="line">    UnixTime m = (UnixTime) msg;</div><div class="line">    System.out.println(m);</div><div class="line">    ctx.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>非常简单优雅是不是？相同的改造同样可以应用于服务器端。让我们先更新 TimeServerHandler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    ChannelFuture f = ctx.writeAndFlush(<span class="keyword">new</span> UnixTime());</div><div class="line">    f.addListener(ChannelFutureListener.CLOSE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，剩下的就是缺少一个编码器。编码器实现了<a href="http://netty.io/4.0/api/io/netty/channel/ChannelOutboundHandler.html" target="_blank" rel="external">ChannelOutboundHandler</a>将 UnixTime 转换成<a href="http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。相对于写解析器而言，写一个编码器是非常简单的，因为它不需要处理包分帧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> io.netty.example.time;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</div><div class="line">        UnixTime m = (UnixTime) msg;</div><div class="line">        ByteBuf encoded = ctx.alloc().buffer(<span class="number">4</span>);</div><div class="line">        encoded.writeInt((<span class="keyword">int</span>)m.value());</div><div class="line">        ctx.write(encoded, promise); <span class="comment">// (1)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>这里有一些需要注意的地方。<br>首先，我们传入<a href="http://netty.io/4.0/api/io/netty/channel/ChannelPromise.html" target="_blank" rel="external">ChannelPromise</a>来将编码后的数据写入连线通道中。<br>其次，我们没有调用 <code>ctx.flush()</code> 方法。这个任务放在了另外一个处理器里面。<br>为了进一步简化代码，你可以使用<a href="">MessageToByteEncoder</a>：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">UnixTime</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, UnixTime msg, ByteBuf out)</span> </span>&#123;</div><div class="line">        out.writeInt((<span class="keyword">int</span>)msg.value());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>最后的任务就是将 TimeEncoder 在 TimeserverHandler 之前插入到<a href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>中。</p>
<h3 id="关闭你的应用"><a href="#关闭你的应用" class="headerlink" title="关闭你的应用"></a>关闭你的应用</h3><p>关闭一个 Netty 应用通常是非常简单的，你要做的仅仅是通过 <code>shutdownGracefully()</code> 方法来关闭掉<a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>S。那个方法会返回一个<a href="http://netty.io/4.0/api/io/netty/util/concurrent/Future.html" target="_blank" rel="external">Future</a>来提醒你<a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>已经完成关闭，并且所有属于这个<a href="http://netty.io/4.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>的<a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>S也会同时关闭。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们快速学习了使用 Netty 来写一个正常工作的网络应用程序。<br>未来的章节里将会有关于 Netty 的更详细的信息。同时我们也鼓励你查阅在<a href="https://github.com/netty/netty/tree/4.0/example/src/main/java/io/netty/example" target="_blank" rel="external">io.netty.example</a>包中的例子。<br>请记住：<a href="http://netty.io/community.html" target="_blank" rel="external">社区</a>期待你的问题反馈，以及改进 Netty 或者其文档的想法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://gxl666.github.io/2016/11/07/User-guide-for-4-x/" data-id="cj0d7u2ee00aazstw12x89wwl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/">Netty</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/09/All-documentation-pages/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          All documentation pages
        
      </div>
    </a>
  
  
    <a href="/2016/11/05/Linux学习-程序管理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux学习-程序管理</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AngularJS官方指南/">AngularJS官方指南</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AngularJS权威指南/">AngularJS权威指南</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dos/">Dos</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTPS/">HTTPS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP权威指南/">HTTP权威指南</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java编程思想/">Java编程思想</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java网络编程/">Java网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OkHttp/">OkHttp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RFC/">RFC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSH/">SSH</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Sonar/">Sonar</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Win7/">Win7</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book/">book</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/boutique/">boutique</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/manpage/">manpage</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/加密/">加密</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/年终总结/">年终总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/深入理解Java虚拟机/">深入理解Java虚拟机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/鸟哥的Linux私房菜/">鸟哥的Linux私房菜</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AngularJS官方指南/">AngularJS官方指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AngularJS权威指南/">AngularJS权威指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dos/">Dos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/">English</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP权威指南/">HTTP权威指南</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java编程思想/">Java编程思想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java网络编程/">Java网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RFC/">RFC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sonar/">Sonar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Win7/">Win7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boutique/">boutique</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/manpage/">manpage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/加密/">加密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/年终总结/">年终总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志/">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入理解Java虚拟机/">深入理解Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/鸟哥的Linux私房菜/">鸟哥的Linux私房菜</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Angular/" style="font-size: 11.25px;">Angular</a> <a href="/tags/AngularJS官方指南/" style="font-size: 10px;">AngularJS官方指南</a> <a href="/tags/AngularJS权威指南/" style="font-size: 16.25px;">AngularJS权威指南</a> <a href="/tags/Dos/" style="font-size: 10px;">Dos</a> <a href="/tags/English/" style="font-size: 11.25px;">English</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HTTP权威指南/" style="font-size: 12.5px;">HTTP权威指南</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java编程思想/" style="font-size: 15px;">Java编程思想</a> <a href="/tags/Java网络编程/" style="font-size: 11.25px;">Java网络编程</a> <a href="/tags/Linux/" style="font-size: 18.75px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 17.5px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 13.75px;">Netty</a> <a href="/tags/OkHttp/" style="font-size: 10px;">OkHttp</a> <a href="/tags/RFC/" style="font-size: 11.25px;">RFC</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/Sonar/" style="font-size: 10px;">Sonar</a> <a href="/tags/Spring/" style="font-size: 11.25px;">Spring</a> <a href="/tags/Win7/" style="font-size: 10px;">Win7</a> <a href="/tags/book/" style="font-size: 11.25px;">book</a> <a href="/tags/boutique/" style="font-size: 10px;">boutique</a> <a href="/tags/manpage/" style="font-size: 10px;">manpage</a> <a href="/tags/加密/" style="font-size: 10px;">加密</a> <a href="/tags/年终总结/" style="font-size: 10px;">年终总结</a> <a href="/tags/日志/" style="font-size: 11.25px;">日志</a> <a href="/tags/深入理解Java虚拟机/" style="font-size: 12.5px;">深入理解Java虚拟机</a> <a href="/tags/鸟哥的Linux私房菜/" style="font-size: 10px;">鸟哥的Linux私房菜</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/17/Java编程思想-Java-I-O系统/">Java编程思想-Java I/O系统</a>
          </li>
        
          <li>
            <a href="/2017/03/16/Java编程思想-初始化和清理/">Java编程思想-初始化和清理</a>
          </li>
        
          <li>
            <a href="/2017/03/16/Java编程思想-吸血鬼数字/">Java编程思想-吸血鬼数字</a>
          </li>
        
          <li>
            <a href="/2017/03/15/鸟哥的Linux私房菜-例行性工作排程/">鸟哥的Linux私房菜-例行性工作排程</a>
          </li>
        
          <li>
            <a href="/2017/03/14/Java编程思想-控制执行流程/">Java编程思想-控制执行流程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 gxl666<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>